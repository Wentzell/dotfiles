#!/usr/bin/env python

# This file will update or generate the copyright header of a given source file
# based on the history provided by the 'git blame -w -M --incremental' command
#
# Usage: gen_copyright file1 [file2 ...] [--appname AppName]
#
# Caution: This will edit the file!

from subprocess import *
from sys import *
from datetime import *
import re

import argparse
parser = argparse.ArgumentParser(description="""
A script to generate GPL Copyright headers for a list of files based on their git history
""")
parser.add_argument('-license', nargs=None, default='Apache', help="The License to use (Apache [default] or GPLv3")
parser.add_argument('-cea', action='store_true', help='Add cea copyright')
parser.add_argument('-cnrs', action='store_true', help='Add cnrs copyright')
args, additional_args = parser.parse_known_args()

license_header = {

    "Apache" : """// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0.txt
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.""",

    "GPL"    :  """// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You may obtain a copy of the License at
//     https://www.gnu.org/licenses/gpl-3.0.txt"""

}

def pretty_years(y):

    s = set(y)
    l = list(y)

    if len(s) == 1:
        return str(l[0])
    else:
        return str(min(l)) + "-" + str(max(l))

    # l = list(s)
    # l.sort()

    # start = None
    # prev = None
    # r = []

    # for x in l:
        # if prev is None:
            # start = x
            # prev = x
            # continue

        # if x == prev + 1:
            # prev = x
            # continue

        # if prev == start:
            # r.append("%i" % prev)
        # else:
            # r.append("%i-%i" % (start, prev))

        # start = x
        # prev = x

    # if not prev is None:
        # if prev == start:
            # r.append("%i" % prev)
        # else:
            # r.append("%i-%i" % (start, prev))

    # return ", ".join(r)

for f in additional_args:

    print("Generating header for file: %s"%f)

    commits = []
    data = {}

    for ln in Popen(["git", "blame", "-w", "-M", "--incremental", f],
                    stdout=PIPE, encoding="utf8").stdout:

        if ln.startswith("filename "):
            if len(data) > 0:
                commits.append(data)
            data = {}

        elif ln.startswith("author "):
            data["author"] = ln[7:].strip()

        elif ln.startswith("author-mail <"):
            data["author-mail"] = ln[12:].strip()

        elif ln.startswith("author-time "):
            data["author-time"] = ln[11:].strip()

        elif ln.startswith("author-tz "):
            data["author-tz"] = ln[9:].strip()

    by_author = {}
    for c in commits:
        try:
            n = by_author[c["author"]]
        except KeyError:
            n = (c["author"], c["author-mail"], set())
            by_author[c["author"]] = n

        year = datetime.fromtimestamp(int(c["author-time"])).year

        n[2].add(year)
    by_author.pop("Not Committed Yet", None)

    for an, a in list(by_author.items()):
        for bn, b in list(by_author.items()):
            if a is b:
                continue

            if a[1] == b[1]:
                a[2].update(b[2])

                if an in by_author and bn in by_author:
                    del by_author[bn]

    copyright = list(by_author.values())

    header = ""

    years = set()
    for author_name, author_mail, author_years in copyright:
        years.update(author_years)
    
    if args.cea or args.cnrs:
        years_gt_2017 = [y for y in years if int(y) > 2017]
        years_lt_2019 = [y for y in years if int(y) < 2019]

        # For <2019 we add a copyright note for CEA / CNRS
        if len(years_lt_2019) > 0:
            if args.cea: header = header + "// Copyright (c) %s Commissariat à l'énergie atomique et aux énergies alternatives (CEA)\n" % (pretty_years(years_lt_2019))
            if args.cnrs: header = header + "// Copyright (c) %s Centre national de la recherche scientifique (CNRS)\n" % (pretty_years(years_lt_2019))

        # For >2017 we add a copyright note for The Simons foundation
        if len(years_gt_2017) > 0:
            header = header + "// Copyright (c) %s Simons Foundation\n" % (pretty_years(years_gt_2017))
    else:
        header = header + "// Copyright (c) %s Simons Foundation\n" % (pretty_years(years))

    header = header + "//\n" + license_header[args.license] + "\n\n"

    if f.endswith('.py') or f.endswith('.txt'): header = re.sub(r"//", "#", header)

    with open(f, "r") as fin: dat = fin.read()
    head_res = {
            'py': [r"^\n?#{10}.*?\n.*?#{10}\n", "^# Copyright.*License.\n\n", "^# Copyright.*gpl-3.0.txt\n\n"],
            'txt': [r"^\n?#{10}.*?\n.*?#{10}\n", "^# Copyright.*License.\n\n", "^# Copyright.*gpl-3.0.txt\n\n"],
            'cpp': [r"^\n?/\*{10}.*?\n.*?\*{10}/\n", "^// Copyright.*License.\n\n", "^// Copyright.*gpl-3.0.txt\n\n"],
            'hpp': [r"^\n?/\*{10}.*?\n.*?\*{10}/\n", "^// Copyright.*License.\n\n", "^// Copyright.*gpl-3.0.txt\n\n"]
            }
    file_ending = f.split(".")[-1]
    for head_re in head_res[file_ending]:
        if re.search(head_re, dat, re.S):
            dat = re.sub(head_re, '', dat, 1, re.S)
    dat = header + dat

    with open(f, "w") as fout: fout.write(dat)
